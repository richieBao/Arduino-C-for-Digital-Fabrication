> by richieBao

> 实验器材：Arduino UNO(1)，面包板(1)，电阻(10kΩ(4，上拉/下拉电阻))，GY-521三轴加速度计电子陀螺仪(1)，AT24C64 EEPROM存储器(1)，OLED显示屏(1)，Tiny RTC I2C可充电电池DS1307芯片时钟模块(1)

# 09_Arudino库
[Libraries](https://www.arduino.cc/en/Reference/Libraries)-Standard Libraries

Libraries-Contributed Libraries

Installing Additional Arduino Libraries

![](_v_images/_1525136591_8051.jpg)

![](_v_images/_1525136602_5734.jpg)


## GY-521三轴加速度计电子陀螺仪
通常所购置的器件模块，厂家都会提供对应单片机的库，往往包含支持Arduino的库文件，如果没有提供，需要查看Arduino官方是否有所提供，以及相关搜索。对于设计专业，在非不得已的情况下不建议自行编写，从而节约时间成本。可以将库文件直接复制到安装目录arduino-1.8.5/libraries下。同时，厂家亦会提供案例文件，学习新模块的最好方法是从所提供的案例文件开始，例如GY-521三轴加速度计电子陀螺仪。

首先阅读器件的手册/说明书，明确引脚、精度、电路和相关说明。并从简单的电路开始实验。
### 电路图(GY-521陀螺仪)
![](_v_images/_1525137693_30012.jpg)

**程序**
```C
// I2C device class (I2Cdev) demonstration Arduino sketch for MPU6050 class
// 10/7/2011 by Jeff Rowberg <jeff@rowberg.net>
// Updates should (hopefully) always be available at https://github.com/jrowberg/i2cdevlib
//
// Changelog:
//     2011-10-07 - initial release

/* ============================================
I2Cdev device library code is placed under the MIT license
Copyright (c) 2011 Jeff Rowberg

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
===============================================
*/

// Arduino Wire library is required if I2Cdev I2CDEV_ARDUINO_WIRE implementation
// is used in I2Cdev.h
#include "Wire.h"

// I2Cdev and MPU6050 must be installed as libraries, or else the .cpp/.h files
// for both classes must be in the include path of your project
#include "I2Cdev.h"
#include "MPU6050.h"

// class default I2C address is 0x68
// specific I2C addresses may be passed as a parameter here
// AD0 low = 0x68 (default for InvenSense evaluation board)
// AD0 high = 0x69
MPU6050 accelgyro;

int16_t ax, ay, az;
int16_t gx, gy, gz;

#define LED_PIN 13
bool blinkState = false;

void setup() {
    // join I2C bus (I2Cdev library doesn't do this automatically)
    Wire.begin();

    // initialize serial communication
    // (38400 chosen because it works as well at 8MHz as it does at 16MHz, but
    // it's really up to you depending on your project)
    Serial.begin(38400);

    // initialize device
    Serial.println("Initializing I2C devices...");
    accelgyro.initialize();

    // verify connection
    Serial.println("Testing device connections...");
    Serial.println(accelgyro.testConnection() ? "MPU6050 connection successful" : "MPU6050 connection failed");

    // configure Arduino LED for
    pinMode(LED_PIN, OUTPUT);
}

void loop() {
    // read raw accel/gyro measurements from device
    accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

    // these methods (and a few others) are also available
    //accelgyro.getAcceleration(&ax, &ay, &az);
    //accelgyro.getRotation(&gx, &gy, &gz);

    // display tab-separated accel/gyro x/y/z values
    Serial.print("a/g:\t");
    Serial.print(ax); Serial.print("\t");
    Serial.print(ay); Serial.print("\t");
    Serial.print(az); Serial.print("\t");
    Serial.print(gx); Serial.print("\t");
    Serial.print(gy); Serial.print("\t");
    Serial.println(gz);

    // blink LED to indicate activity
    blinkState = !blinkState;
    digitalWrite(LED_PIN, blinkState);
}
```
**运行结果**
```
a/g:	16668	-452	-392	-840	181	377
a/g:	16564	-352	-324	-819	180	356
a/g:	16656	-368	-392	-825	157	356
a/g:	16588	-440	-272	-814	149	398
a/g:	16604	-424	-320	-825	161	359
a/g:	16600	-416	-348	-836	174	380
a/g:	16652	-420	-328	-804	161	405
a/g:	16676	-356	-296	-839	169	369
a/g:	16764	-356	-288	-848	183	377
a/g:	16812	-464	-348	-813	177	382
a/g:	16720	-392	-352	-815	159	383
a/g:	16628	-404	-428	-807	133	400
a/g:	16600	-436	-308	-827	197	383
a/g:	16612	-400	-520	-820	166	364
a/g:	16664	-404	-252	-824	167	375
a/g:	16572	-392	-256	-845	166	360
a/g:	16592	-420	-280	-818	165	362
a/g:	16720	-408	-312	-798	175	365
a/g:	16608	-324	-220	-811	144	367
a/g:	16624	-400	-272	-829	171	378
a/g:	16576	-408	-476	-847	174	375
a/g:	16700	-352	-292	-824	167	384
a/g:	16696	-432	-216	-819	157	380
```
## I2C通信
两线串行通信接口(I2C/TWI):TWI子系统允许使用两线互连的方案将一系列相关设备，如微控制器、传感器、显示器、记忆存储器等设备，以网络的形式连接在同一系统中。TWI接口最大能同时连接128个设备。其中每个设备具备独立的设备地址，并且能在两线的总线上以高达400kHz的速率进行通信。因此可以通过TWI接口设备之间在小范围的网络中自由交换数据。
> I2C的通信机制部分作为了解，有助于理解和使用。

TWI(2-wire Serial Interface，ⅈ^2
* 主机：能产生TWI总线的SCL时钟信号，控制启动和停止传输的器件；
* 从机：和主机进行数据交换的器件，从机不能主动发起数据传输以及产生时钟信号；
* 发送器：向TWI总线提供数据的器件；
* 接收器：从TWI总线上读取数据的器件；
* 多主机：同一条TWI总线上有多个可能会同时使用总线的主机；
* 主器件地址：主机的内部地址，每一种主器件有其特定且唯一的主器件地址；
* 从器件地址：从机的内部地址，每一种从器件有其特定且唯一的从器件地址；
* 仲裁过程：当同时有多个主机尝试操作总线时，TWI总线使得其中一个主机获得总线的使用权，同时并不破坏报文的过程；
* 同步过程：两个或两个以上器件同步时钟信号的过程。

![](_v_images/_1525138741_6491.jpg)

TWI总线由时钟线SCL和数据线SDA组成。一般TWI总线上连接的器件是漏极或集电极开路结构，因此两根总线均需要通过电阻上拉到Vcc，确保总线上任意一个器件在输出低电平时会将总线拉低，实现"线与"，即TWI总线上的时钟信号SCL是由所有挂接在该信号线上器件的SCL信号进行逻辑"与"产生。当这些器件中任何一个SCL引脚的电平被拉低之后，SCL信号将一直保持低电平，当所有器件的SCL引脚都恢复到高电平之后，SCL总线才能恢复为高电平状态，因此总线上SCL时钟信号长度由维持电平时间最长的器件决定。在下一个时钟周期内，第一个SCL引脚被拉低的器件又再次将SCL总线拉低，形成连续的SCL时钟信号。

TWI总线工作在7位地址模式时，可以挂接2^7=128个器件，每个器件均有唯一的地址。
### TWI总线数据传输格式
#### 传输位(Transferring Bits)
TWI总线协议规定总线上进行数据位传输时需要与时钟脉冲同步。在数据传送过程中，当时钟线为高电平时，数据线上的电平必需保持稳定。
![](_v_images/_1525139180_2054.jpg)

#### 起始和停止条件(START and STOP Conditions)
TWI总线协议规定在时钟线SCL为高电平时，数据线SDA从高电平向低电平的跳变被定义为起始条件。当时钟线SCL为高电平时，数据线SDA从低电平向高电平的跳变被定义为停止条件。重复起始条件的定义与起始条件的定义同。

TWI总线上数据传输都是以主机产生的起始条件(START)开始，已主机产生的停止条件(STOP)终止。在起始条件之后TWI总线被认为进入了忙状态。有时，也可以在一个起始条件之后，再产生一个起始条件，为重复起始条件(REPEATED START)。同样，当重复起始条件之后，总线仍然被认定为忙状态。
![](_v_images/_1525139311_5148.jpg)

#### 地址帧格式(Address Packet Format)
TWI 总线协议规定一个地址帧由9位构成，包含7位的从器件地址、1位读写控制位和1位应答位。主机首先将7位的从器件地址按高位在前，低位在后的顺序依次放置在总线上，然后主机发送一个读写控制位，读写控制位为1时，表示接下来主机要对从机进行读操作，而当读写控制位为0时，则为写操作。从机在检测到自身被寻址后，在第9个时钟周期开始前将SDA线拉低做出应答(ACK)。

7位地址可以由用户定义，但是从机地址0000 000是系统的保留地址，该地址是作为广播呼叫地址使用，当主机需要发送相同的信息给总线上所有的从器件时，即可以使用广播呼叫功能。当主机发送0000 000+0时，表示要对总线上所有从器件进行写操作，所有从器件都会在第9个时钟到来前将SDA线拉低做出应答，并且会将主机随后发生的数据写入器件内部。主机发送0000 000+1，则是对所有器件进行读操作，是无意义的，因此地址操作无效。此外，从机地址1111 xxx为保留地址，未被定义也不能使用。
![](_v_images/_1525139513_27656.jpg)

#### 数据帧格式(Data Packet Format)
TWI总线上一个数据帧由9位构成，包括8个数据位、1个应答位。数据的高位在前，低位在后。总线上发送数据的一方为发生器，接收数据一方为接收器。当8位数据发送完毕，接收器第9个时钟到来前拉低SDA线以产生应答型号(ACK)。当接收器由于某种原因不能继续接收数据时，可以在第9个时钟到来时不拉低SDA线，即产生一个非应答(NACK)信号，以此通知发生器不要继续发送数据。
![](_v_images/_1525139666_8812.jpg)

#### 地址+数据的发送(Combining Address and Data Packets into a Transmission)
基本传输包括起始条件、从器件地址、R/W位、至少一个数据包以及一个停止条件构成。在数据传送时，主机首先发送起始条件，启动本次数据传输，然后主机发送要寻址的从器件地址与R/W位。从机被寻址后，在地9个时钟到来时将SDA线拉低，产生应答ACK信号。随后，按照主机发送的地址包的读写要求，从机将自身的数据放到总线上供主机读取，或者将主机发送的数据写入从机内。无论主机和从机，只要作为接收数据的一方，在数据接收完毕后都将会将SDA线拉低产生一个应答ACK信号。

当主机时钟频率设定高于从机所能接受的速度极限时，从机会利用总线"线与"，在没有完成数据响应时将SCL线拉低，使时钟因低电平时间延长而降低总线上数据传输速率。
![](_v_images/_1525139852_27830.jpg)

### TWI结构框图
![](_v_images/_1525140223_3498.jpg)

### TWI总线模块编程
![](_v_images/_1525140359_4804.jpg)

### TWI寄存器
![](_v_images/_1525140752_21827.jpg)

![](_v_images/_1525140763_15186.jpg)

## AT24C64 EEPROM存储器
ATmega328微控制器(Arduino UNO核心)受制于ROM存储容量的限制，如果碰到存储较多数据时则不能够实现程序运行，例如文字数据和图片数据，此时需要扩展容量。一种较为简单的方法是使用AT24C64外置EEPROM存储器，型号64的存储器容量：64Kbit。具体参数可以查看Atmel的官方手册。
**Features**
* Low-Voltage and Standard-Voltage Operation
– 2.7 (VCC = 2.7V to 5.5V)
– 1.8 (VCC = 1.8V to 5.5V)
* Low-Power Devices (ISB = 2 µA at 5.5V) Available
* Internally Organized 4096 x 8, 8192 x 8
* 2-Wire Serial Interface **支持iic**
* Schmitt Trigger, Filtered Inputs for Noise Suppression
* Bidirectional Data Transfer Protocol
* 100 kHz (1.8V, 2.5V, 2.7V) and 400 kHz (5V) Clock Rate
* Write Protect Pin for Hardware Data Protection
* 32-Byte Page Write Mode (Partial Page Writes Allowed)
* Self-Timed Write Cycle (10 ms max)
*  High Reliability
– Endurance: 1 Million Write Cycles
– Data Retention: 100 Years
*  Automotive Grade and Extended Temperature Devices Available
* 8-Pin JEDEC PDIP, 8-Pin JEDEC SOIC, 8-Pin EIAJ SOIC,and 8-pin TSSOP Packages
**引脚与封装**
![](_v_images/_1525170046_22449.jpg)

### 把字库写入AT24C64
*font.c字库*
```C
const unsigned char F6X8[][6] =    
{
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},// sp
{0x00, 0x00, 0x00, 0x2f, 0x00, 0x00},// !
{0x00, 0x00, 0x07, 0x00, 0x07, 0x00},// "
{0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14},// #
{0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12},// $
{0x00, 0x62, 0x64, 0x08, 0x13, 0x23},// %
{0x00, 0x36, 0x49, 0x55, 0x22, 0x50},// &
{0x00, 0x00, 0x05, 0x03, 0x00, 0x00},// '
{0x00, 0x00, 0x1c, 0x22, 0x41, 0x00},// (
{0x00, 0x00, 0x41, 0x22, 0x1c, 0x00},// )
{0x00, 0x14, 0x08, 0x3E, 0x08, 0x14},// *
{0x00, 0x08, 0x08, 0x3E, 0x08, 0x08},// +
{0x00, 0x00, 0x00, 0xA0, 0x60, 0x00},// ,
{0x00, 0x08, 0x08, 0x08, 0x08, 0x08},// -
{0x00, 0x00, 0x60, 0x60, 0x00, 0x00},// .
{0x00, 0x20, 0x10, 0x08, 0x04, 0x02},// /
{0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E},// 0
{0x00, 0x00, 0x42, 0x7F, 0x40, 0x00},// 1
{0x00, 0x42, 0x61, 0x51, 0x49, 0x46},// 2
{0x00, 0x21, 0x41, 0x45, 0x4B, 0x31},// 3
{0x00, 0x18, 0x14, 0x12, 0x7F, 0x10},// 4
{0x00, 0x27, 0x45, 0x45, 0x45, 0x39},// 5
{0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30},// 6
{0x00, 0x01, 0x71, 0x09, 0x05, 0x03},// 7
{0x00, 0x36, 0x49, 0x49, 0x49, 0x36},// 8
{0x00, 0x06, 0x49, 0x49, 0x29, 0x1E},// 9
{0x00, 0x00, 0x36, 0x36, 0x00, 0x00},// :
{0x00, 0x00, 0x56, 0x36, 0x00, 0x00},// ;
{0x00, 0x08, 0x14, 0x22, 0x41, 0x00},// <
{0x00, 0x14, 0x14, 0x14, 0x14, 0x14},// =
{0x00, 0x00, 0x41, 0x22, 0x14, 0x08},// >
{0x00, 0x02, 0x01, 0x51, 0x09, 0x06},// ?
{0x00, 0x32, 0x49, 0x59, 0x51, 0x3E},// @
{0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C},// A
{0x00, 0x7F, 0x49, 0x49, 0x49, 0x36},// B
{0x00, 0x3E, 0x41, 0x41, 0x41, 0x22},// C
{0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C},// D
{0x00, 0x7F, 0x49, 0x49, 0x49, 0x41},// E
{0x00, 0x7F, 0x09, 0x09, 0x09, 0x01},// F
{0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A},// G
{0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F},// H
{0x00, 0x00, 0x41, 0x7F, 0x41, 0x00},// I
{0x00, 0x20, 0x40, 0x41, 0x3F, 0x01},// J
{0x00, 0x7F, 0x08, 0x14, 0x22, 0x41},// K
{0x00, 0x7F, 0x40, 0x40, 0x40, 0x40},// L
{0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F},// M
{0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F},// N
{0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E},// O
{0x00, 0x7F, 0x09, 0x09, 0x09, 0x06},// P
{0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E},// Q
{0x00, 0x7F, 0x09, 0x19, 0x29, 0x46},// R
{0x00, 0x46, 0x49, 0x49, 0x49, 0x31},// S
{0x00, 0x01, 0x01, 0x7F, 0x01, 0x01},// T
{0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F},// U
{0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F},// V
{0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F},// W
{0x00, 0x63, 0x14, 0x08, 0x14, 0x63},// X
{0x00, 0x07, 0x08, 0x70, 0x08, 0x07},// Y
{0x00, 0x61, 0x51, 0x49, 0x45, 0x43},// Z
{0x00, 0x00, 0x7F, 0x41, 0x41, 0x00},// [
{0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55},// 55
{0x00, 0x00, 0x41, 0x41, 0x7F, 0x00},// ]
{0x00, 0x04, 0x02, 0x01, 0x02, 0x04},// ^
{0x00, 0x40, 0x40, 0x40, 0x40, 0x40},// _
{0x00, 0x00, 0x01, 0x02, 0x04, 0x00},// '
{0x00, 0x20, 0x54, 0x54, 0x54, 0x78},// a
{0x00, 0x7F, 0x48, 0x44, 0x44, 0x38},// b
{0x00, 0x38, 0x44, 0x44, 0x44, 0x20},// c
{0x00, 0x38, 0x44, 0x44, 0x48, 0x7F},// d
{0x00, 0x38, 0x54, 0x54, 0x54, 0x18},// e
{0x00, 0x08, 0x7E, 0x09, 0x01, 0x02},// f
{0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C},// g
{0x00, 0x7F, 0x08, 0x04, 0x04, 0x78},// h
{0x00, 0x00, 0x44, 0x7D, 0x40, 0x00},// i
{0x00, 0x40, 0x80, 0x84, 0x7D, 0x00},// j
{0x00, 0x7F, 0x10, 0x28, 0x44, 0x00},// k
{0x00, 0x00, 0x41, 0x7F, 0x40, 0x00},// l
{0x00, 0x7C, 0x04, 0x18, 0x04, 0x78},// m
{0x00, 0x7C, 0x08, 0x04, 0x04, 0x78},// n
{0x00, 0x38, 0x44, 0x44, 0x44, 0x38},// o
{0x00, 0xFC, 0x24, 0x24, 0x24, 0x18},// p
{0x00, 0x18, 0x24, 0x24, 0x18, 0xFC},// q
{0x00, 0x7C, 0x08, 0x04, 0x04, 0x08},// r
{0x00, 0x48, 0x54, 0x54, 0x54, 0x20},// s
{0x00, 0x04, 0x3F, 0x44, 0x40, 0x20},// t
{0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C},// u
{0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C},// v
{0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C},// w
{0x00, 0x44, 0x28, 0x10, 0x28, 0x44},// x
{0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C},// y
{0x00, 0x44, 0x64, 0x54, 0x4C, 0x44},// z
{0x14, 0x14, 0x14, 0x14, 0x14, 0x14}// horiz lines
};

const unsigned char  F8X16[][16]=   
{
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},// 0
  {0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00},//! 1
  {0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//" 2
  {0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00},//# 3
  {0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00},//$ 4
  {0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00},//% 5
  {0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10},//& 6
  {0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//' 7
  {0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},//( 8
  {0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},//) 9
  {0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},//* 10
  {0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00},//+ 11
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00},//, 12
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01},//- 13
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},//. 14
  {0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00},/// 15
  {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},//0 16
  {0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//1 17
  {0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},//2 18
  {0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00},//3 19
  {0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00},//4 20
  {0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00},//5 21
  {0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00},//6 22
  {0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},//7 23
  {0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},//8 24
  {0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00},//9 25
  {0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},//: 26
  {0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00},//; 27
  {0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},//< 28
  {0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00},//= 29
  {0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},//> 30
  {0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00},//? 31
  {0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00},//@ 32
  {0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},//A 33
  {0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},//B 34
  {0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},//C 35
  {0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},//D 36
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},//E 37
  {0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},//F 38
  {0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},//G 39
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},//H 40
  {0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//I 41
  {0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},//J 42
  {0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00},//K 43
  {0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00},//L 44
  {0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00},//M 45
  {0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},//N 46
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},//O 47
  {0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},//P 48
  {0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00},//Q 49
  {0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},//R 50
  {0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},//S 51
  {0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},//T 52
  {0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},//U 53
  {0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},//V 54
  {0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00},//W 55
  {0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},//X 56
  {0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},//Y 57
  {0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},//Z 58
  {0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00},//[ 59
  {0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00},//\ 60
  {0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00},//] 61
  {0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//^ 62
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80},//_ 63
  {0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//` 64
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20},//a 65
  {0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00},//b 66
  {0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00},//c 67
  {0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20},//d 68
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00},//e 69
  {0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//f 70
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00},//g 71
  {0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},//h 72
  {0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//i 73
  {0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00},//j 74
  {0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},//k 75
  {0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},//l 76
  {0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F},//m 77
  {0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20},//n 78
  {0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},//o 79
  {0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00},//p 80
  {0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80},//q 81
  {0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00},//r 82
  {0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00},//s 83
  {0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00},//t 84
  {0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20},//u 85
  {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00},//v 86
  {0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00},//w 87
  {0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00},//x 88
  {0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00},//y 89
  {0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00},//z 90
  {0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},//{ 91
  {0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},//| 92
  {0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},//} 93
  {0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}//~ 94
};
```
*主程序*
```C
///richieBao 2018-05-01
extern const unsigned char F6X8[][6];
extern const unsigned char F8X16[][16];

#include <Wire.h>
#define disk 0x50 
int n=0;

void setup() {
  Serial.begin(9600);
  int i,j;
  Wire.begin(); // join i2c bus (address optional for master)
  
//  for(i=0;i<92;i++)for(j=0;j<6;j++) {
//    AT24C64_WriteByte(disk,i*6+j,F6X8[i][j]);  //写入字库F6X8，起始地址0
//    //Serial.println(F6X8[i][j],HEX);
//    //delay(100);
//  }
//  //552
//  for(i=0;i<20;i++){
//    char temp=AT24C64_ReadByte(disk,i);//读取字库F6X8      
//    Serial.println(temp,HEX);  //发送至串口
//    delay(100);
//  }  
 
  for(i=0;i<95;i++)for(j=0;j<16;j++) AT24C64_WriteByte(disk,1000+i*16+j,F8X16[i][j]);  //写入字库F8X16，起始地址1000 
  for(i=0;i<30;i++){
    char temp=AT24C64_ReadByte(disk,1000+i);  //读取字库F8X16       
    Serial.println(temp,HEX);  //发送至串口
    delay(100);
  }
  /*
   unsigned int address = 0;
   AT24C64_WriteByte(disk, address, 123);
   Serial.print(AT24C64_ReadByte(disk, address), DEC); 
*/
}

byte x = 0;

void loop() {

}

void AT24C64_WriteByte(int slave_addr,unsigned int addr,unsigned int dat){  
    //byte rdata = 0xFF;
    Wire.beginTransmission(slave_addr); 
    Wire.write(addr >> 8);   //写入从器件内存地址高字节
    Wire.write(addr & 0xFF); //写入从器件内存地址低字节
    Wire.write(dat);  //写入1个字节数据
    Wire.endTransmission(); 
    delay(5);
}

byte AT24C64_ReadByte(int slave_addr,unsigned int addr){
    byte rdata = 0xFF;
    Wire.beginTransmission(slave_addr);  //发送至子器件slave_addr地址(Wire库中，子地址均右移1位)
    Wire.write(addr >> 8); // 子器件内存地址MSB高字节
    Wire.write(addr & 0xFF); // 子器件内存地址LSB低字节
    Wire.endTransmission();  //停止传送
    Wire.requestFrom(slave_addr,1);  //从子器件地址读取1字节
    if (Wire.available()) rdata = Wire.read();  //读取指定子器件指定内存地址数据
    return rdata;
}

void IIC_Write_CMD(byte cmd){
   Wire.beginTransmission(0x78>>1);  //子器件地址右移一位
   Wire.write(0x00);  
   Wire.write(cmd); 
   Wire.endTransmission();
}

void IIC_Write_DAT(byte dat){
   Wire.beginTransmission(0x78>>1);
   Wire.write(0x40); 
   Wire.write(dat); 
   Wire.endTransmission();
}

```
> 注意，因为受到Atmega328存储容量的限制，在将字库写入到AT24C64时，是将两组数组，F6X8[][6]和F8X16[][16]分别写入，一个写入到地址为0的开始位置，另一个写入到地址为1000开始的位置。关于读写AT24C64可以参考官方手册。亦可以直接复用上述代码。

## OLED显示屏
读取模拟端两只光敏电阻的数据，并将该数据送入OLED显示屏显示，文字从AT24C64中读入。其中OLED显示屏和AT24C64均为iiC通信。此时因为AT24C64内部无上拉电阻，因此在电路设计时，需要在SCL和SDA引脚增加两只10k上拉电阻。
**电路图**
![](_v_images/_1525170968_20833.jpg)

**实际搭建**
![](_v_images/_1525170999_2202.jpg)

**程序**
```C
//richieBao 2016-10-10
//modified by richieball 2018-05-01
#include <Wire.h>  //包含Arduino的TWI库
//#define uchar unsigned char
//#define uint unsigned int
#define disk 0x50 

void IIC_Write_CMD(byte cmd);
void IIC_Write_DAT(byte dat);
void OLED_init();
void fill(byte dat);
void OLED_PosSet(unsigned char x,unsigned char y);
void OLED_Clr();
byte AT24C64_ReadByte(int slave_addr,unsigned int addr);
void OLED_ShowChar(int x,int y,unsigned char chr,int chrSize);
void OLED_ShowString(int x,int y,unsigned char *chr,int charSize);
unsigned int oled_pow(unsigned char m,unsigned char n);
void OLED_ShowNum(unsigned char x,unsigned char y,unsigned int num,unsigned int len,unsigned char NUMsize);

#define Max_Column 128  //OLED的列数，控制显示屏横向显示的范围
unsigned char temp;
unsigned int i;

const int leftPhotoresistance=2;  //光敏电阻1接入模拟引脚2
const int rightPhotoresistance=3;  //光敏电阻2接入模拟引脚3
const int minPwm=128;  //设置映射范围最小，在DC电机部分会进一步通过控制范围调整转速
const int maxPwm=256;  //设置映射范围最大

void setup() {  //同main()函数部分，但分离出while(1){ }部分
  Wire.begin();  //启动TWI
  Serial.begin(9600);  //启动串口，监视  
  OLED_init();    //初始化OLED液晶屏
  
  OLED_Clr();  //清屏
  OLED_ShowString(28,6,"MuBenTECH",6);
  OLED_ShowString(0,0,"LPRVal:",16);
  OLED_ShowString(0,3,"RPRVal:",16);
  
}

void loop() {  //即main()函数while(1){ }部分
  int leftPhotoR=analogRead(leftPhotoresistance);  //读入光敏电阻1的值
  int mapLeftPhotoR=map(leftPhotoR,0,1023,minPwm,maxPwm);  //将读入光敏电阻1的值映射在指定范围
  int rightPhotoR=analogRead(rightPhotoresistance);  //读入光敏电阻2的值
  int mapRightPhotoR=map(rightPhotoR,0,1023,minPwm,maxPwm);  //将读入光敏电阻2的值映射在指定范围
  
  OLED_ShowNum(55,1,mapLeftPhotoR,3,6);  //在OLED屏上显示光敏电阻1映射后的值
  OLED_ShowNum(55,4,mapRightPhotoR,3,6); //在OLED屏上显示光敏电阻2映射后的值
  //OLED_ShowNum(55,1,leftPhotoR,3,6);
  //OLED_ShowNum(55,4,rightPhotoR,3,6);
  delay(500);
}

byte AT24C64_ReadByte(int slave_addr,unsigned int addr){
    byte rdata = 0xFF;
    Wire.beginTransmission(slave_addr);  //发送至子器件slave_addr地址(Wire库中，子地址均右移1位)
    Wire.write(addr >> 8); // 子器件内存地址MSB高字节
    Wire.write(addr & 0xFF); // 子器件内存地址LSB低字节
    Wire.endTransmission();  //停止传送
    Wire.requestFrom(slave_addr,1);  //从子器件地址读取1字节
    if (Wire.available()) rdata = Wire.read();  //读取指定子器件指定内存地址数据
    return rdata;
}

void IIC_Write_CMD(byte cmd){
   Wire.beginTransmission(0x78>>1);  //子器件地址右移一位
   Wire.write(0x00);  
   Wire.write(cmd); 
   Wire.endTransmission();
}

void IIC_Write_DAT(byte dat){
   Wire.beginTransmission(0x78>>1);
   Wire.write(0x40); 
   Wire.write(dat); 
   Wire.endTransmission();
}

void OLED_init(){
  IIC_Write_CMD(0xAE);   
  IIC_Write_CMD(0x20);  
  IIC_Write_CMD(0x10);  
  IIC_Write_CMD(0xb0);  
  IIC_Write_CMD(0xc8);  
  IIC_Write_CMD(0x00);
  IIC_Write_CMD(0x10);
  IIC_Write_CMD(0x40);
  IIC_Write_CMD(0x81);
  IIC_Write_CMD(0xdf);
  IIC_Write_CMD(0xa1);
  IIC_Write_CMD(0xa6);
  IIC_Write_CMD(0xa8);
  IIC_Write_CMD(0x3F);
  IIC_Write_CMD(0xa4);
  IIC_Write_CMD(0xd3);
  IIC_Write_CMD(0x00);
  IIC_Write_CMD(0xd5);
  IIC_Write_CMD(0xf0);
  IIC_Write_CMD(0xd9);
  IIC_Write_CMD(0x22); 
  IIC_Write_CMD(0xda);
  IIC_Write_CMD(0x12);
  IIC_Write_CMD(0xdb);
  IIC_Write_CMD(0x20);
  IIC_Write_CMD(0x8d);
  IIC_Write_CMD(0x14);
  IIC_Write_CMD(0xaf);  
}

void OLED_PosSet(unsigned char x,unsigned char y){
  IIC_Write_CMD(0xB0+y);
  IIC_Write_CMD(((x&0xF0)>>4)|0x10);
  IIC_Write_CMD(x&0x0F);
}

void OLED_Clr(){
  unsigned char i,j;
  for(i=0;i<8;i++){
  IIC_Write_CMD(0xB0+i);
  IIC_Write_CMD(0x00);
  IIC_Write_CMD(0x10);
  for(j=0;j<128;j++) IIC_Write_DAT(0);
  }
}

void fill(byte dat){
  unsigned char x,y;
  for(y=0;y<8;y++){
      IIC_Write_CMD(0xb0+y);
      IIC_Write_CMD(0x0);
      IIC_Write_CMD(0x10);
      for(x=0;x<128;x++){
          IIC_Write_DAT(dat);
        }
    }
}

void OLED_ShowChar(int x,int y,unsigned char chr,int chrSize){
  int j=0,i=0;
  j=chr-' ';
  if(x>Max_Column-1){x=0;y=y+2;}
  if(chrSize==16){  
    OLED_PosSet(x,y);
    for(i=0;i<8;i++) IIC_Write_DAT(AT24C64_ReadByte(disk,1000+j*16+i));
    OLED_PosSet(x,y+1);
    for(i=0;i<8;i++) IIC_Write_DAT(AT24C64_ReadByte(disk,1000+j*16+i+8));
  }else{
    OLED_PosSet(x,y);
    for(i=0;i<6;i++)
    IIC_Write_DAT(AT24C64_ReadByte(disk,j*6+i));              
  }
}

void OLED_ShowString(int x,int y,unsigned char *chr,int charSize){
  int j=0;
  while(chr[j]!='\0'){
    OLED_ShowChar(x,y,chr[j],charSize);
    x+=8;
    if(x>120){x=0;y+=2;}
    j++;
  }
}

unsigned int oled_pow(unsigned char m,unsigned char n){
  unsigned int result=1;   
  while(n--)result*=m;    
  return result;
} 

void OLED_ShowNum(unsigned char x,unsigned char y,unsigned int num,unsigned int len,unsigned char NUMsize){
  unsigned char t,temp,EnShow=0;
  for(t=0;t<len;t++){
    temp=(num/oled_pow(10,len-t-1))%10;
    if(EnShow==0&&t<(len-1)){
      if(temp==0){
        OLED_ShowChar(x+(NUMsize)*t,y,' ',NUMsize);
        continue;       
      }else EnShow=1; 
    }
    OLED_ShowChar(x+(NUMsize)*t,y,temp+'0',NUMsize);
  }
}
```
> 处理使用上述程序外，也可以从Arduino库中自行搜索支持的库，例如Adafruit SSD1306库。但是此库如果在Atmega328下使用，将占去较大存储容量，一种方法时更好Arduino其它容量大的板子，二是使用本次实验的程序，配合外置存储器解决存储容量问题。

## Tiny RTC I2C可充电电池DS1307芯片时钟模块
需要安装三个库，[从此处下载](http://playground.arduino.cc/Code/Time)解压后复制到arduino-1.8.5\libraries，Time, TimeAlarms, 和 DS1307RTC 。
![](_v_images/_1525176839_1024.jpg)

此处为DS1307RTC库示例代码，未作修改，复制于此，方便查询。
*SetTime*
```C
#include <Wire.h>
#include <TimeLib.h>
#include <DS1307RTC.h>

const char *monthName[12] = {
  "Jan", "Feb", "Mar", "Apr", "May", "Jun",
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

tmElements_t tm;

void setup() {
  bool parse=false;
  bool config=false;

  // get the date and time the compiler was run
  if (getDate(__DATE__) && getTime(__TIME__)) {
    parse = true;
    // and configure the RTC with this info
    if (RTC.write(tm)) {
      config = true;
    }
  }

  Serial.begin(9600);
  while (!Serial) ; // wait for Arduino Serial Monitor
  delay(200);
  if (parse && config) {
    Serial.print("DS1307 configured Time=");
    Serial.print(__TIME__);
    Serial.print(", Date=");
    Serial.println(__DATE__);
  } else if (parse) {
    Serial.println("DS1307 Communication Error :-{");
    Serial.println("Please check your circuitry");
  } else {
    Serial.print("Could not parse info from the compiler, Time=\"");
    Serial.print(__TIME__);
    Serial.print("\", Date=\"");
    Serial.print(__DATE__);
    Serial.println("\"");
  }
}

void loop() {
}

bool getTime(const char *str)
{
  int Hour, Min, Sec;

  if (sscanf(str, "%d:%d:%d", &Hour, &Min, &Sec) != 3) return false;
  tm.Hour = Hour;
  tm.Minute = Min;
  tm.Second = Sec;
  return true;
}

bool getDate(const char *str)
{
  char Month[12];
  int Day, Year;
  uint8_t monthIndex;

  if (sscanf(str, "%s %d %d", Month, &Day, &Year) != 3) return false;
  for (monthIndex = 0; monthIndex < 12; monthIndex++) {
    if (strcmp(Month, monthName[monthIndex]) == 0) break;
  }
  if (monthIndex >= 12) return false;
  tm.Day = Day;
  tm.Month = monthIndex + 1;
  tm.Year = CalendarYrToTm(Year);
  return true;
}
```
*ReadTest*
```C
#include <Wire.h>
#include <TimeLib.h>
#include <DS1307RTC.h>

void setup() {
  Serial.begin(9600);
  while (!Serial) ; // wait for serial
  delay(200);
  Serial.println("DS1307RTC Read Test");
  Serial.println("-------------------");
}

void loop() {
  tmElements_t tm;

  if (RTC.read(tm)) {
    Serial.print("Ok, Time = ");
    print2digits(tm.Hour);
    Serial.write(':');
    print2digits(tm.Minute);
    Serial.write(':');
    print2digits(tm.Second);
    Serial.print(", Date (D/M/Y) = ");
    Serial.print(tm.Day);
    Serial.write('/');
    Serial.print(tm.Month);
    Serial.write('/');
    Serial.print(tmYearToCalendar(tm.Year));
    Serial.println();
  } else {
    if (RTC.chipPresent()) {
      Serial.println("The DS1307 is stopped.  Please run the SetTime");
      Serial.println("example to initialize the time and begin running.");
      Serial.println();
    } else {
      Serial.println("DS1307 read error!  Please check the circuitry.");
      Serial.println();
    }
    delay(9000);
  }
  delay(1000);
}

void print2digits(int number) {
  if (number >= 0 && number < 10) {
    Serial.write('0');
  }
  Serial.print(number);
}
```
